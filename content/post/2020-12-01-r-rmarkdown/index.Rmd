---
title: "Analyzing App Reviews in R"
author: "Tato Lu"
date: "10/24/2021"
categories: ["R"]
tags: ["R Markdown", "plot", "regression"]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE)
```

Sentiment analysis is a popular text mining technique that analyzes the underlying sentiment of a text and tells whether the sentiment is positive, negative, or neutral. It offers another helpful metric that can help businesses understand public opinion of their product or service.

To demonstrate, I conduct a simple sentiment analysis in R using review data from the Apple app store. I'm a fan of the webtoon app Tapas, having published comics on it before, so I'm curious to know what people think of the app.

# Setup

If you want to follow along at home, the packages you need for this analysis are:
1. appler: to import app reviews 
2. dplyr, data.table: for data manipulation
3. 
(_disclaimer: the App Store API only allows users to download the latest 500 reviews_)

```{r, include = FALSE}
# Package names
packages <- c('appler', 'dplyr', 'data.table', 
              'tidytext', 'syuzhet', 
              'tm', 'tidyr', 'ggplot2', 
              'textclean', 'lubridate', 'stringr',
              'textstem')

# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# Packages loading
invisible(lapply(packages, library, character.only = TRUE))
```

First, let's take a look at the data we're working with. The appler packages allows us to retrieve the 500 latest app reviews for a given app and geography. I decided to focus on US reviews for the Tapas app.
```{r}
#Get latest app reviews
#reviews_raw <- get_apple_reviews(578836126, country = 'us', all_results = TRUE)
#saveRDS(reviews_raw, file = 'app_reviews.rds')
reviews_raw <- readRDS('app_reviews.rds')
```

We can use the nrow and ncol functions to see how big the data is.
```{r}
nrow(reviews_raw)
ncol(reviews_raw)
```
So we have 500 reviews, with 7 variables to work with. 

```{r, include = FALSE}
lapply(reviews_raw, class)
```

With R's head function, we can take a look at the first few rows of the data. The variables we'll be working with most are review_time, app_version, rating, and review.
```{r}
head(reviews_raw)
```

# Exploratory Analysis

Before diving into the data, it'll help to know where, or *when*, the data are coming from. Let's plot the distribution of reviews of time.
```{r}
reviews <- reviews_raw %>% 
  mutate(review_time = as.Date(review_time), 
         month = lubridate::floor_date(review_time, 'month'))

ggplot(reviews, aes(x = review_time)) + 
  geom_histogram() + 
  scale_x_date(date_breaks = "1 month", date_labels =  "%b %y") +
  ggtitle('Count of Reviews Over Time')
```

We can also look at how ratings changed over time.
```{r}
avg_rating <- reviews %>% group_by(month) %>% summarize(avg_rating = mean(rating))
ggplot(avg_rating, aes(x = month, y = avg_rating)) +
  geom_line() +
  scale_x_date(date_breaks = "1 month", date_labels =  "%b %y") +
  ylim(0, 5) +
  ggtitle('Average Rating Over Time')
```
Interestingly, it looks like...

#Investigate changes to the app version
```{r}
reviews <- reviews %>% mutate(app_version_clean = str_extract(as.character(app_version), '5\\.[0-9]{1,2}'))
app_ver_order <- reviews %>% 
  select(app_version_clean) %>%
  unique() %>% 
  arrange(as.integer(substr(app_version_clean, 3, nchar(app_version_clean)))) %>%
  unlist()

reviews <- reviews %>% mutate(app_version_clean = factor(app_version_clean, levels = app_ver_order))

version_count <- reviews %>% 
  group_by(app_version_clean, month) %>% 
  summarize(n_reviews = n()) %>%
  ungroup() %>%
  complete(app_version_clean, month, fill = list(n_reviews = 0)) %>%
  arrange(app_version_clean)

version_prop <- version_count %>% 
  group_by(month) %>% 
  mutate(percentage = n_reviews/sum(n_reviews))

ggplot(version_prop, aes(x = month, y = percentage, fill = app_version_clean)) + 
  geom_area() + 
  scale_x_date(date_breaks = "1 month", date_labels =  "%b %y") +
  scale_y_continuous(labels = scales::percent) + 
  ggtitle('App Versions Over Time')
```

#Plot average rating by app version
```{r}
avg_rating_by_ver <- reviews %>% 
  group_by(app_version_clean) %>%
  summarize(avg_rating = mean(rating)) %>%
  arrange(app_version_clean)

ggplot(avg_rating_by_ver, aes(x = app_version_clean, y = avg_rating)) + 
  geom_bar(stat = 'identity') +
  ylim(0, 5) +
  ggtitle('Average Rating by App Version')
```

# Text Mining

## Sentiment Analysis

# Clean reviews
```{r}
#Replace contracted words with non-contracted words (e.g., "I'm" to "I am")
reviews <- reviews %>% mutate(review_cleaned = gsub('’','\'',review))
reviews <- reviews %>% mutate(review_cleaned = replace_contraction(review_cleaned))

#Remove white spaces
reviews <- reviews %>% mutate(review_cleaned = gsub('\\n',' ', review_cleaned))

#Remove punctuation and numbers
reviews <- reviews %>% mutate(review_cleaned = gsub('[[:punct:]0-9 “”‘]+',' ', review_cleaned))

#Remove emojis
reviews$review_cleaned <- sapply(reviews$review_cleaned, function(row) iconv(row, "latin1", "ASCII", sub=""))

#Convert to lower case
reviews <- reviews %>% mutate(review_cleaned = tolower(review_cleaned))

#Remove stop words and other common, unhelpful words
reviews <- reviews %>% mutate(review_cleaned = removeWords(review_cleaned, 
                                                           c('app',
                                                             'tapas',
                                                             'will',
                                                             'can',
                                                             'just',
                                                             'now',
                                                             'read',
                                                             'comic',
                                                             'get',
                                                             stopwords(kind = 'en'))))

#Lemmatize words ("apples" to "apple")
reviews <- reviews %>% mutate(review_cleaned = lemmatize_strings(review_cleaned))

#Show example: before and after
reviews$review[1]
reviews$review_cleaned[1]
```

#Get sentiment scores
```{r}
reviews <- reviews %>% 
  mutate(sentiment_score = get_sentiment(review_cleaned, method = 'syuzhet'),
         sentiment_direction = case_when(
           sign(sentiment_score) > 0 ~ 'positive',
           sign(sentiment_score) == 0 ~ 'neutral',
           sign(sentiment_score) < 0 ~ 'negative'
           )
         )
```

#Reviews with negative sentiment
```{r}
reviews %>% filter(sentiment_direction == 'negative') %>% head() %>% select(review, review_cleaned)
```

#Reviews with positive sentiment. Sentiment is good at picking up negative reviews, but gets confused with positive reviews, especially if it has mixed language.
```{r}
reviews %>% filter(sentiment_direction == 'positive') %>% head() %>% select(review, review_cleaned)
```

#Plot proportion of positive, neutral, and negative reviews over time.
```{r}
sent_bars <- reviews %>% 
  group_by(month, sentiment_direction) %>%
  summarize(percentage = n())

ggplot(sent_bars, aes(fill = sentiment_direction, x = month, y = percentage)) +  
  geom_bar(position = 'fill', stat = 'identity') +
  scale_x_date(date_breaks = "1 month", date_labels =  "%b %y") +
  scale_y_continuous(labels = scales::percent) + 
  scale_fill_manual(values = c('red3', 'yellow3', 'green3')) + 
  ggtitle('Sentiment Over Time')
```

#Plot proportion of positive, neutral, and negative reviews over time.
```{r}
sent_ver <- reviews %>% 
  group_by(app_version_clean, sentiment_direction) %>%
  summarize(percentage = n())

ggplot(sent_ver, aes(fill = sentiment_direction, x = app_version_clean, y = percentage)) +  
  geom_bar(position = 'fill', stat = 'identity') +
  scale_y_continuous(labels = scales::percent) + 
  scale_fill_manual(values = c('red3', 'yellow3', 'green3')) + 
  ggtitle('Sentiment by App Version')
```